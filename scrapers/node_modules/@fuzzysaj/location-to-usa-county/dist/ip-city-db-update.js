"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const path = require("path");
const util_1 = require("util");
const file_utils_1 = require("./file-utils");
const debug_1 = require("debug");
const debug = debug_1.default('location-to-usa-county');
const ipCityRootName = 'GeoLite2-City';
const finalIpCityFilePath = path.resolve(__dirname, '../data/', ipCityRootName + '.mmdb');
const tempIpCityFilePath = path.resolve(__dirname, '../data/', ipCityRootName + '.temp.mmdb');
const ipCityUrl = 'https://geolite.maxmind.com/download/geoip/database/' + ipCityRootName + '.tar.gz';
const msPerDay = 1000 * 60 * 60 * 24;
const daysBetweenIpCityUpdates = 7;
const msBetweenIpCityDbUpdates = daysBetweenIpCityUpdates * msPerDay; // 7 days between updates
/** Deletes final and temporary ip to city db files if they exist.  Returns void. */
async function delIpCityFile() {
    await file_utils_1.delFileIfExists(tempIpCityFilePath);
    await file_utils_1.delFileIfExists(finalIpCityFilePath);
}
exports.delIpCityFile = delIpCityFile;
/** Returns true if final city to ip db file exists and size > 0 bytes. */
async function okIpCityFile() {
    return await file_utils_1.fileSizeInBytes(finalIpCityFilePath) > 0;
}
exports.okIpCityFile = okIpCityFile;
/** Returns true if the regions GeoJson db file exists, and is
 * greater than 0 bytes and is not older than 30 days old.
 */
async function isIpCityFileCurrent() {
    return ((await okIpCityFile()) &&
        ((await file_utils_1.msSinceLastUpdate(finalIpCityFilePath)) < msBetweenIpCityDbUpdates));
}
exports.isIpCityFileCurrent = isIpCityFileCurrent;
/** When the regions ip to city file does not exist, or when when it is
 * more than 7 days since last update, the city to ip file is
 * downloaded to a temporary file and is renamed to the final file
 * if success.  If not successful, the original file remains.
 * Returns true on success.
 */
async function updateIpCityFile() {
    if (await isIpCityFileCurrent()) {
        const daysOld = ((await file_utils_1.msSinceLastUpdate(finalIpCityFilePath)) / msPerDay).toFixed(1);
        debug(`Skipping download since ${finalIpCityFilePath} already exists ` +
            `and is ${daysOld} < ${daysBetweenIpCityUpdates} days old.`);
        return true;
    }
    debug(`Downloading\n  ${ipCityUrl}\n  to\n  ${tempIpCityFilePath}`);
    try {
        const status = await file_utils_1.extractMatchingTarGz(ipCityUrl, /GeoLite2-City\.mmdb/, tempIpCityFilePath);
        debug(`Finished downloading ${tempIpCityFilePath} with status ${status}.`);
        await util_1.promisify(fs.rename)(tempIpCityFilePath, finalIpCityFilePath);
        debug(`Renamed to ${finalIpCityFilePath}`);
        return true;
    }
    catch (err) {
        debug(`Download to ${tempIpCityFilePath} failed: ${err.toString()}`);
        return false;
    }
}
exports.updateIpCityFile = updateIpCityFile;
//# sourceMappingURL=ip-city-db-update.js.map